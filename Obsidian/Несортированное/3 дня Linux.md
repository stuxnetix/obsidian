
## 1. Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания.

Процесс загрузки Linux с момента нажатия кнопки питания можно разделить на пять стадий:
1. Загрузчик. Во время старта машины BIOS передаёт управление загрузчику, который находит образ ядра Linux на диске и загружает его в память. 
2. Запуск и первичная инициализация ядра.  Ядро проверяет и обращается к аппаратным средствам. 
3. Обнаружение оборудования, загрузка драйверов и подключение файловых систем. 
4. Запуск системных служб (демонов). 
5. Старт графической или консольной пользовательской сессии. 

Более подробно процесс загрузки Linux можно рассмотреть на следующих примерах:
* POST (Self-On Self Test) — выполняет общую проверку аппаратных компонентов компьютера. Когда POST завершает работу, он передаёт управление загрузчику. 
* GRUB — самый популярный загрузчик в Linux.  Он имеет встроенную командную строку, работает с десятком различных файловых систем и позволяет формировать сложные цепочки загрузки. 

---


## 2. Что такое POSIX


POSIX (англ. Portable Operating System Interface — переносимый интерфейс операционных систем) — набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системный API), библиотеку языка C и набор приложений и их интерфейсов. 

Стандарт создан для обеспечения совместимости различных UNIX-подобных операционных систем и переносимости прикладных программ на уровне исходного кода, но может быть использован и для не-Unix систем. 

Серия стандартов POSIX была разработана комитетом 1003 IEEE. Международная организация по стандартизации (ISO) совместно c Международной электротехнической комиссией (IEC) приняла стандарт POSIX под названием ISO/IEC 9945. 
Название «POSIX» было предложено Ричардом Столлманом. «POSIX» является зарегистрированным товарным знаком IEEE.

---


## 3.Что такое уровни выполнения


Уровень выполнения (runlevel) в Linux — это режим функционирования операционной системы, который определяет, какие задачи могут выполняться в текущем состоянии. Чем выше номер уровня, тем больше функций. 1

Традиционно существуют шесть уровней выполнения, пронумерованные от 0 до 6:

0 — полная остановка системы и выключение устройства. 1
1 — однопользовательский режим, предназначен для различных административных действий по восстановлению системы. 1
2 — многопользовательский режим без поддержки сети (иногда используется как эквивалент уровня 3). 1
3 — многопользовательский режим с поддержкой сети, нормальный режим работы сервера. 1
5 — загрузка в многопользовательском режиме с графическим входом в систему. 1
6 — перезагрузка системы. 1
В некоторых дистрибутивах Linux могут встречаться и другие уровни выполнения. 3

Администратор системы может переводить её с одного уровня выполнения на другой. В большинстве систем проверить текущий уровень можно командой runlevel. 1

---



## 4. Какие основные части компоненты включает в себя система на базе дистрибутива linux?

Основные компоненты операционной системы Linux:
1. Ядро — основной компонент ОС, взаимодействует с аппаратным обеспечением, выступает посредником между низкоуровневым железом и компонентами верхнего уровня. 
2. Оболочка — интерфейс для взаимодействия между ядром ОС и пользователями, абстрагирует внутреннее устройство системы, получает команды от пользователей, запускает необходимые функции. 
3. Утилиты — вспомогательные компьютерные программы в составе общего ПО. Они нужны для выполнения типовых задач, связанных с работой оборудования и ОС. 
4. Компиляторы — технические средства, преобразующие программный код в машинный. 
5. Системные библиотеки — это специальные программы, дающие доступ к функциям ядра. 
6. Утилиты разработки ПО — набор программ, инструментов и утилит, который помогает создавать рабочее приложение из исходных кодов. 
7. Пользовательские программы — они не считаются обязательными компонентами ОС, нередко их пишут сами пользователи. К таким утилитам относятся браузеры, офисные пакеты, инструменты графического дизайна, плееры и пр..

---


## 5. Что такое BIOS, UEFI?

BIOS (Basic Input/Output System) — базовая система ввода/вывода, прошивка, которая находится на микросхеме материнской платы компьютера и инициализирует центральный процессор, оперативную память, карты PCIe и сетевые устройства. 

UEFI (Unified Extensible Firmware Interface) — унифицированный расширяемый интерфейс встроенного программного обеспечения, спецификация, которая определяет архитектуру встроенного программного обеспечения платформы, используемого для загрузки компьютерного оборудования, и его интерфейс для взаимодействия с операционной системой.  UEFI заменяет BIOS и совместим с ним, что позволяет запускать старые операционные системы. 

UEFI обладает следующими преимуществами:
* поддерживает жёсткие диски большего объёма; 
* обеспечивает более быструю загрузку; 
* поддерживает дискретные драйверы; 
* обеспечивает безопасную загрузку, предотвращая загрузку компьютера из неавторизированных приложений; 
* работает в 32-битном или 64-битном режиме; 
* обладает графическим интерфейсом, поддерживающим мышь.

---


## 6. Что такое PXE? Как загрузиться по сети?


PXE (англ. Preboot eXecution Environment, произносится пикси) — среда для загрузки компьютеров с помощью сетевой карты без использования локальных носителей данных (жёсткого диска, USB-накопителя и т. п.). 

Процесс загрузки с помощью PXE:
1. Клиент подключается к сети и опрашивает DHCP-сервер для аренды IP. 
2. DHCP-сервер передаёт клиенту IP и другую необходимую для сетевой загрузки информацию. 
3. Затем клиент подключается к TFTP-серверу по протоколу TFTP (который очень похож на обычный FTP) и загружает файлы. 
4. После этого клиент загружает систему со скаченных файлов. 

Чтобы загрузиться по сети через PXE, необходимо:
1. В настройках BIOS или UEFI компьютера выбрать в качестве первичного устройства загрузки PXE. 
2. При запуске среды PXE компьютер обнаружит в сети DHCP-сервер, получит IP-адрес и доступные опции в меню PXE. 

---


## 7. Что такое ядро, initramfs, загрузчик?


Ядро — сердце операционной системы. Оно функционирует на низком уровне, являясь посредником между аппаратным обеспечением компьютера и прикладными программами. 

Initramfs (initial RAM filesystem, начальная файловая система) — образ файловой системы, загружаемый в оперативную память вместе с ядром.  Основные задачи этого образа: монтирование реального корня файловой системы и запуск процесса init, лежащего на нём. 

Загрузчик — программа, которая загружает операционную систему. Это особая программа, потому что она работает ещё до того, как загрузилось ядро и другие программы.  Сегодня загрузкой Linux практически в любом дистрибутиве занимается Grub.

---

## 8. Зачем нужна система инициализации?


Система инициализации — это критически важный компонент, который определяет, как операционная система запускается и загружается. Эта система служит первым уровнем, который вступает в действие сразу после запуска ядра, выполняя роль связующего звена между ядром ОС и высокоуровневыми приложениями. 

Система инициализации выполняет несколько ключевых задач:
1. Запуск процессов. Она инициирует и управляет различными процессами, необходимыми для работы системы и пользовательских приложений: управление сетевыми соединениями, системными логами, планировщиком задач и другими критически важными сервисами. 
2. Управление зависимостями. Система инициализации управляет порядком и условиями запуска служб, обеспечивая правильное разрешение всех необходимых зависимостей и запуск сервисов в нужном порядке. 
3. Контроль за процессами. После начальной загрузки система инициализации продолжает контролировать работающие процессы, перезапуская службы в случае их сбоя или остановки для обеспечения стабильности и надёжности системы. 
4. Играет важную роль в процессе выключения и перезагрузки системы, корректно останавливая службы и процессы для безопасного завершения работы системы.


---

## 9. Что такое systemd и init ?

Init — это процесс инициализации в Linux.  Он запускается ядром сразу после завершения загрузки и продолжает выполняться, пока работает система.  В процессе инициализации последовательно выполняются важные проверки, запускаются необходимые системные процессы, а потом и приложения, непосредственно взаимодействующие с пользователем. Когда же работа завершена, именно init выключает компьютер. 

Systemd — это новая система инициализации Linux. Она была введена по умолчанию в Fedora 15, а сейчас используется почти во всех популярных дистрибутивах Linux. Это не только инициализирующий процесс, но и набор инструментов для управления службами и этими возможностями из системы. Основная цель — иметь полный контроль над всеми процессами во время их запуска и на протяжении всего выполнения.



---


## 10. Как понять используется ли в системе systemd?


Чтобы понять, используется ли в системе systemd, можно воспользоваться следующими методами:

1. Проверить процесс с PID 1. Для этого можно использовать команду  ps -p 1 -o comm= . Если в результате появится «systemd», то система использует systemd в качестве системы инициализации. 
2. Проверить наличие исполняемых файлов systemd в PATH. Для этого можно использовать команду  which systemd . Если в результате появится путь, например, /bin/systemd или /usr/lib/systemd/systemd, то это означает, что systemd установлен и, вероятно, контролирует систему. 
3. Проверить символическую ссылку процесса /sbin/init. Для этого можно использовать команду  ls -l /sbin/init . Если она указывает на systemd (например, /lib/systemd/systemd), то система использует systemd в качестве системы инициализации. 



---

## 11. Опишите, что происходит (с точки зрения процессов), при выполнении любой команды в консоли, например: ls -l


Когда пользователь вводит команду в консоли, командная оболочка выполняет следующие действия:
1. Анализ команды: выделение имени, параметров и аргументов. 
2. Если это встроенная команда, для неё вызывается функция-обработчик. 
3. Если это внешняя команда, производится поиск программы с соответствующим именем. 
4. Создаётся дочерний процесс оболочки (системный вызов fork). 
5. В дочернем процессе запускается необходимая команда с расшифрованными параметрами и аргументами (системный вызов exec). 
6. Оболочка контролирует выполнение дочернего процесса, передаёт ему сигналы и ввод пользователя, ожидает его завершения (системный вызов wait). 
7. Результаты работы возвращаются пользователю, отображается приглашение — он может вводить следующую команду. 

Например, при выполнении команды ls -l:
1. Команда выводит информацию в расширенном формате, который содержит больший объём информации о каждом файле (права доступа, размер, дата последней модификации и т. д.). 

Пока выполняется команда, могут происходить и другие вещи (вывод списка файлов может быть долгим, если их очень много). Например, пользователь может переключиться на другую виртуальную консоль или отправить и получить почту.


---

## 12. Как работает система разграничения доступа к файлам в linux?

Система разграничения доступа к файлам в Linux базируется на именах пользователей и группах пользователей. Каждый пользователь может входить в одну или несколько групп и иметь права доступа в зависимости от группы, в которую он входит. 

Для всех файлов и директорий Linux устанавливаются следующие права доступа:
* разрешение на чтение содержимого файла; 
* разрешение на изменение (запись) содержимого файла; 
* разрешение на исполнение файла. 

В свойствах каждого файла и директории эти три разрешения устанавливаются отдельно для:
* владельца файла; 
* группы владельцев файла, которой принадлежит этот файл; 
* всех остальных. 

Каждый пользователь может получить полный доступ только к файлам, владельцем которых он является, или к тем, доступ к которым ему разрешён. Только пользователь Root может работать со всеми файлами независимо от их набора полномочий. 
Для назначения и изменения прав доступа используется команда chmod (сокращённо от change mode). Она вводится в командную строку по следующей логике: chmod кто=права файл/каталог.


---






## 13.  Как посмотреть нагрузку на диски?


1. Для общего анализа дисковой активности можно воспользоваться утилитой btrace из пакета blktrace. 
2. Наглядный вывод статистики по дисковым устройствам в режиме реального времени есть у iostat из пакета sysstat. 
3. Более детально в режиме реального времени нагрузку на диск отдельных приложений можно посмотреть с помощью iotop. 
4. Ещё один вариант отображения активности процессов в режиме реального времени — pidstat. 
5. Посмотреть, в какие файлы производится запись, можно с помощью fatrace. 
6. Более детально разобраться с тем, что пишет процесс на диск, можно с помощью strace, указав ему в качестве параметра PID процесса. 
7. Посмотреть список открытых файлов в конкретной директории можно с помощью lsof. 


---


## 14. Что значит `$@` в bash?



В языке программирования Bash знак доллара ($) используется для обозначения переменных. Он указывает Bash на то, что следующая строка должна быть обработана как значение переменной. 

Например, если нужно вывести текущее время, можно использовать следующую команду: echo "The current time is: $TIME". В этом случае значение переменной TIME будет заменено текущим временем. 

Также знак доллара может использоваться для подстановки аргументов командной строки в сценарии Bash. Например, если есть сценарий с именем myscript, можно передать ему аргументы, используя знак доллара: myscript "$1" "$2" "$3". Здесь $1, $2 и $3 обозначают первый, второй и третий аргументы командной строки соответственно. Эти аргументы будут заменены значениями, переданными в командной строке при вызове сценария. 

---

## 15. Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?


Чтобы перенаправить сообщения об ошибках STDERR в файл, вместо того чтобы выводить их на экран, можно использовать дескриптор файла с номером 2. 

Например:  ls -l xfile 2> myfile . 

Если нужно, чтобы весь вывод (стандартная ошибка и стандартный вывод) отправлялся в один файл, можно воспользоваться командой  &> . 
Важно помнить, что при работе с командной строкой необходимо соблюдать осторожность.




---

## 16.Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?


- Используйте команду date с флагом -r, чтобы показать дату последней модификации файла. 

- Запустите команду ls с флагом -l, чтобы получить длинный список форматов файлов, который включает дату последнего изменения файла. 

- Используйте команду stat, чтобы посмотреть все временные метки файла, в том числе время последней модификации. 
---


## 17.  Как работает sudo? Для чего она используется?

Sudo (англ. Substitute User and do, дословно «подменить пользователя и выполнить») — программа для системного администрирования UNIX-систем, позволяющая делегировать те или иные привилегированные ресурсы пользователям с ведением протокола работы. 

Принцип работы:
1. Пользователь передаёт в параметре нужную команду утилите sudo. 
2. Утилита выполняется от имени root. 
3. Она читает свои настройки, запрашивает пароль пользователя и решает, можно ли ему разрешать выполнение команд от имени администратора. 
4. Если да, то выполняется переданная в параметре команда. 

Основная идея sudo — дать пользователям как можно меньше прав, при этом достаточных для решения поставленных задач. 
Правила, используемые sudo для принятия решения о предоставлении доступа, находятся в файле /etc/sudoers. Для редактирования файла можно использовать специальный редактор visudo, запускаемый из командной строки без параметров, в том числе без указания пути к файлу.


---

## 18. Что такое userspace, kernelspace? Чем они отличаются?

Kernel space — это пространство памяти, где выполняется ядро операционной системы (kernel) и предоставляет свои услуги. Оно зарезервировано для работы драйверов устройств, ядра ОС и всех других расширений ядра. 

User space (также известное как userland) — это пространство памяти, где выполняются все пользовательские приложения или прикладное программное обеспечение. Всё, кроме ядер ОС и ядра, работает здесь. 
Основное назначение этого разделения — защита памяти и оборудования от вредоносного или ошибочного поведения программного обеспечения.

---


## 19.  Что такое системные вызовы?


Системный вызов (англ. system call) в программировании и вычислительной технике — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции. 
С точки зрения программиста, системный вызов обычно выглядит как вызов подпрограммы или функции из системной библиотеки. 
В Linux системные вызовы делятся на пять категорий:
1. Управление процессами: fork(), exec(), wait(), exit(). 
2. Управление файлами: open(), read(), write(), close(). 
3. Управление устройствами: ioctl(). 
4. Информационное обеспечение: getpid(), alarm(), sleep(). 
5. Взаимодействие между процессами: pipe(), shmget(), mmap(). 
В Linux существует около 380 разных системных вызовов.


---

## 20. Где можно найти информацию о конкретном системном вызове?


Чтобы найти информацию о конкретном системном вызове, можно воспользоваться следующими ресурсами:
* man с именем системного вызова. Этот способ позволяет просмотреть документацию по системному вызову. 
* Файл /usr/include/sys/syscall.h. В этом файле содержится список системных вызовов ядра. 
* Исходный код ядра Linux. Можно использовать grep для поиска SYSCALL_DEFINE в исходном коде ядра. 

---


## 21. Что делает команда kill?


Команда kill (с англ. — «убить») — одна из стандартных функций операционных систем семейства UNIX.  Она позволяет отправлять сигналы процессам, что позволяет контролировать их поведение. 
Основное использование команды kill — отправка сигнала процессу. По умолчанию команда kill отправляет процессу сигнал TERM (15), что приводит к стандартной остановке процесса.

Примеры использования:
* Чтобы послать процессу сигнал KILL (9), который немедленно прекратит выполнение процесса, используйте следующий синтаксис: kill -9 PID. Замените PID на идентификатор процесса. 

* С помощью команды kill можно отправлять сигнал всей группе процессов. Разные процессы могут иметь одинаковый идентификатор группы (PGID). Пример использования: kill -SIGTERM -- -PGID. Замените PGID на идентификатор группы процессов. 

---


## 22. Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией?


Чтобы понять, является ли текущая нагрузка на сервер нормальной, необходимо проанализировать её совместно с другими показателями. 

Load Average — среднее значение загруженности системы за период времени. Три числа показывают усреднённую нагрузку за последние 1, 5 и 15 минут. 

Если речь идёт о системе с одним ядром CPU, то:

load average <1 — идеальная ситуация, сервер не нагружен; 
load average 1–3 — сервер нагружен, но работает в нормальном режиме; 
load average 3–10 — сервер загружен довольно сильно, надо следить за нагрузкой и выявлять причины такой нагрузки; 
load average >10 — сервер перегружен, надо принимать меры; 
load average >20 — сервер сильно тормозит, трудно получить ответ сервера. 

Проверить значение Load Average в Linux можно с помощью следующих команд:
* uptime — один из наиболее распространённых методов. Чтобы выполнить команду, откройте терминал и введите: uptime. 
* top — ещё один способ мониторинга Load Average. Для этого откройте терминал и введите: top. 
* glances — это утилита мониторинга системы, которая работает аналогично команде top. Она даёт подробный обзор использования системных ресурсов.


---

## 23. Что такое процесс? Что такое тред? В чем заключаются их главные отличия?

Процесс — это абстракция, которая инкапсулирует в себе все ресурсы процесса (открытые файлы, файлы, отображённые в память) и их дескрипторы. Каждый процесс имеет своё собственное виртуальное адресное пространство и контекст выполнения. 

Поток (thread) — это сущность операционной системы, процесс выполнения на процессоре набора инструкций, программного кода. Общее назначение потоков — параллельное выполнение на процессоре двух или более различных задач. Планировщик ОС, руководствуясь приоритетом потока, распределяет кванты времени между разными потоками и ставит потоки на выполнение.

---


## 24. Где в linux хранится информация о процессах?


Информация о процессах в Linux хранится в директории /proc, где N — числовой идентификатор процесса. 
В этой директории содержатся различные псевдо-файлы, которые содержат информацию о самом процессе и связанном с ним окружении: 
* /proc/N/cmdline — содержимое командной строки, которой был запущен процесс; 
* /proc/N/environ — описание окружения, в котором работает процесс; 
* /proc/N/exe — символическая ссылка на выполнимый файл запущенной программы; 
* /proc/N/limits — лимиты на использование системных ресурсов, актуальные для работающего процесса; 
* /proc/N/mounts — список смонтированных ресурсов, которые доступны процессу; 
* /proc/N/status — статус работающей программы. 
Также для просмотра информации о процессах можно использовать утилиты ps и top.




---

## 25. Представлен вывод команды _top_. Что означает каждая запись в выводе?

Команда top — это консольная команда в Linux, которая выводит список работающих в системе процессов и информацию о них. По умолчанию она в реальном времени сортирует процессы по нагрузке на процессор. 
В выводе команды top могут отображаться следующие столбцы:
1. PID — идентификатор процесса. 
2. USER — имя пользователя, запустившего процесс. 
3. PR — приоритет процесса. 
4. NI — изменённый приоритет (присвоенный пользователем с помощью команды nice). 
5. VIRT — объём используемой виртуальной памяти. 
6. RES — объём используемой оперативной памяти. 
7. SHR — объём памяти, разделяемой с другими процессами. 
8. S — статус процесса (running — запущен; sleeping — в ожидании; zombie — процесс-«зомби»). 
9. %CPU — процент использования процессорного времени. 
10. %MEM — процент использования оперативной памяти. 
11. TIME+ — общее время работы процесса. 
12. COMMAND — имя процесса (команда, которой был запущен процесс). 
Информация в выводе команды top помогает оценить, какой объём ресурсов потребляют процессы, и оптимизировать работу системы.


---


## 26. Что показывает статус процессов? Какие статусы используются в linux?


Статусы процессов в Linux показывают, в каком состоянии они находятся в текущий момент. 
Вот некоторые статусы и их обозначения:
1. Running (R) — процесс выполняется или готов к выполнению. 
2. Sleeping (S) — процесс находится в состоянии ожидания какого-то события, сигнала или освобождения нужного ресурса. 
3. Disk Sleep (D) — процесс находится в состоянии непрерываемого ожидания, его нельзя убить или прервать. 
4. Stopped (T) — процесс остановлен, обычно после получения сигнала. 
5. Zombie (Z) — это завершённый процесс, который закончил выполнение, но всё ещё имеет запись в таблице процессов, чтобы сообщить об этом своему родительскому процессу. 
6. Dead (X) — мёртвый процесс, это переходное состояние, которое устанавливается перед тем, как дескриптор процесса будет освобождён. 
Для получения более точной и подробной информации о статусе процесса рекомендуется обратиться к соответствующей документации.


---


## 27. Что такое зомби-процесс?

Процесс-зомби — это дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения. 
Проблемы, которые могут вызывать зомби-процессы:
1. Зомби не занимают памяти, но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом. При достижении лимита записей все процессы пользователя не будут способны создавать новые дочерние процессы. 
2. Если родительский процесс выполняется от имени суперпользователя, для освобождения записей (перезапуска процесса) может потребоваться перезагрузка. 
3. Ряд ошибок программирования может приводить к возникновению и накоплению в системе необрабатываемых процессов-зомби (то есть уже завершившихся процессов, родитель которых не считывает их статус). Это приводит к «утечке ресурсов» в виде накопления записей в таблице процессов. 
Важно помнить, что один или два зомби-процесса не причинят вреда системе, но значительное их количество может нарушить её работу.


---

## 28. Чем опасны зомби процессы, какие проблемы они могут создать?

Зомби не занимают памяти (как [процессы-сироты](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%B8%D1%80%D0%BE%D1%82%D0%B0) ), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.

При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор _sh_ должен создать новый процесс)

Иногда, если родительский процесс выполняется от имени суперпользователя, для освобождения записей (перезапуска процесса) может потребоваться перезагрузка (причём зачастую — только аппаратным рестартом). Некоторые операционные системы (например, [Sun Solaris](https://ru.wikipedia.org/wiki/Solaris) ) при возникновении такой ситуации аварийно завершают часть выполняющихся процессов, восстанавливая работоспособность системы.

---



## 29.Что такое SIGCHLD?

SIGCHLD — сигнал, посылаемый в POSIX-системах при изменении статуса дочернего процесса (завершён, приостановлен или возобновлён). 
Этимология: SIG — общий префикс сигналов, CHLD — сокращённое написание англ. child — ребёнок, дочерний объект (английский компьютерный жаргон). 
Использование: в Unix процесс может порождать «дочерние» процессы системным вызовом fork() или его вариантами. Родительский процесс, если он существует, уведомляется системой о завершении дочерних процессов (или изменении их состояния) сигналом SIGCHLD. Родительский процесс не должен предпринимать для этого никаких действий. Сигнал может быть игнорирован, если не нуждается в обработке (по умолчанию он игнорируется).



---



## 30. Что такое файловый дескриптор

Файловый дескриптор — натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода.  Он может быть связан с файлом, каталогом, сокетом. 
Когда процесс открывает существующий файл или создаёт новый, ядро возвращает ему файловый дескриптор. Чтобы выполнить запись в файл или чтение из него, нужно передать его файловый дескриптор, полученный в результате вызова функции open или creat. 
По умолчанию Unix-оболочки связывают:
* файловый дескриптор 0 — с потоком стандартного ввода (клавиатура); 
* файловый дескриптор 1 — с потоком стандартного вывода (терминал); 
* файловый дескриптор 2 — со стандартным выводом ошибок (диагностические и отладочные сообщения, информация об ошибках). 
Файловые дескрипторы могут принимать значения от 0 до OPEN_MAX. 
В операционной системе Windows для получения дескриптора файла используется функция CreateFile. Затем полученный дескриптор используется для работы с этим файлом.

---


## 31. Для чего нужны сигналы? Какие сигналы используются чаще всего?

Сигналы в Linux — это программные прерывания, которые посылаются процессу, когда случается некоторое событие.  Они предоставляют пользователю (или процессу) возможность напрямую взаимодействовать с процессом. 
Некоторые часто используемые сигналы:
1. SIGHUP — закрытие терминала. 
2. SIGINT — сигнал остановки процесса пользователем с терминала (CTRL + C). 
3. SIGQUIT — сигнал остановки процесса пользователем с терминала (CTRL + ) с дампом памяти. 
4. SIGKILL — безусловное завершение процесса. 
5. SIGTERM — сигнал запроса завершения процесса. 
6. SIGSTOP — принудительная приостановка выполнения процесса, но не завершение его работы. 
7. SIGTSTP — приостановка процесса с терминала (CTRL + Z), но не завершение работы. 
8. SIGCONT — продолжение выполнения ранее остановленного процесса.




---


## 32. Как осуществляется обработка сигналов? Чем отличается SIGTERM от SIGKILL?


SIGTERM (Signal Terminate) — сигнал, который используется для завершения программы в UNIX-подобных системах. 35 Его также можно назвать «мягким уничтожением», поскольку процесс, который получает сигнал SIGTERM, может игнорировать его. 

SIGKILL — сигнал, который используется для немедленного прекращения процесса. 35 Этот сигнал нельзя игнорировать или заблокировать. Процесс будет завершён вместе с его потоками (если есть). 

Различия между SIGTERM и SIGKILL:

SIGTERM грациозно убивает процесс, тогда как SIGKILL убивает процесс немедленно. 
Сигнал SIGTERM может обрабатываться, игнорироваться и блокироваться, но SIGKILL не может быть обработан или заблокирован. 
SIGTERM не убивает дочерние процессы, SIGKILL также убивает дочерние процессы. 
Важно помнить, что SIGKILL не позволяет процессу закрыться правильно, что может привести к утечке ресурсов, потере данных или другим проблемам. Поэтому его следует использовать только как последнее средство. 

---

## 33. Какой сигнал получит активный процесс при нажатии Ctrl+C в консоли?

При нажатии CTRL + C в консоли генерируется сигнал SIGINT, который отправляется всем процессам, выполняющимся в оболочке. Это приводит к завершению их работы.


---

## 34. Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?

Load Average (средняя нагрузка) — это метрика, которая отображает среднюю нагрузку на CPU за определённый период времени. Эти значения представляют собой количество процессов, ожидающих выполнения на CPU или использующих его в данный период. 

В Linux Load Average представляется тремя десятичными значениями: 

Первое показывает среднюю нагрузку на CPU за последнюю минуту. 
Второе даёт среднюю нагрузку за последний 5-минутный интервал. 
Третье значение показывает среднюю загрузку за последние 15 минут. 
Это помогает пользователю понять, как процессы в системе нагружают CPU с течением времени. 

Чем ниже эта величина, тем менее загружены вычислительные мощности. 

---

## 35. Можно ли сделать так, чтобы пользователи могли получать информацию только о своих процессах?


Чтобы пользователи в Linux имели доступ только к необходимым ресурсам, можно использовать инструмент AppArmor. Он позволяет настроить параметры безопасности различных конфигурационных файлов: пользователей, групп пользователей или процессов. 

Также для ограничения прав доступа к файлам и каталогам можно использовать команду chmod (сокращённо от change mode).  Она вводится в командную строку по следующей логике: chmod кто=права файл/каталог. Вместо «кто» нужно подставить обозначение того, для кого будут назначены права доступа. Например: u — владелец файла, g — группа, которой принадлежит файл, o — остальные пользователи. 

---
## 36. Что такое физическая память?

Физическая память — это оперативная память компьютера (ОЗУ). Она называется так потому, что реализована в виде реально существующих микросхем. 3 Эта память является энергозависимой и имеет ограниченный размер. 

В физической памяти хранятся инструкции программ для выполнения, и это единственный тип хранилища, к которому центральный процессор может получить прямой доступ. 

---


## 37. Что такое виртуальная память?


Виртуальная память в Linux — это концепция, которая создаёт иллюзию наличия у каждого процесса своего личного пространства памяти. Она позволяет системе исполнять код приложений, используя больший объём памяти, чем физически доступно. Это достигается путём сброса неиспользуемых блоков памяти приложений на диск. 

Виртуальная память подразделяется на:

Виртуальную память (VSZ) — это память, которую выделили процессу, но не факт, что он успел в эту память что-то записать. 
Резидентную память (RSS) — это память, которую процесс занял, то есть что-то сохранил в виртуальную память.  Именно резидентная память показывает, сколько процесс потребляет физической памяти. 
Общий объём физической памяти и пространств подкачки также называется виртуальной памятью.

---









## 38.  Где в системе можно посмотреть сводку по текущему потреблению памяти?

Чтобы посмотреть сводку по текущему потреблению памяти в Linux, можно воспользоваться следующими инструментами:

- Файл /proc/meminfo. 13 Это автоматически обновляемый файл, который содержит информацию о памяти. 

- Команда free. Она показывает общее количество и количество свободной физической памяти и файла подкачки, а также буфера ядра. 

- Команда vmstat. Она отображает статистические данные по использованию CPU, памяти, прерываний и ввода-вывода на диск. 

- Команда top.  Она выводит список запущенных процессов в режиме реального времени, а также различные статистические данные для каждого из них. 

- Программа htop.  Она показывает использование процессора и памяти для каждого процесса по отдельности в реальном времени. 

- Программа nmon. Она позволяет тестировать центральный процессор, память, диск, ввод-вывод, ядро, файловую систему и сетевые ресурсы в интерактивном режиме. 

- Команда ps. Она может показать использование памяти для каждого процесса в реальном времени. 

- Команда smem. Она позволяет измерить количество памяти, используемое различными процессами и пользователями на основе информации, взятой из /proc. 

---


## 39. Как работает оом киллер и для чего нужен?

Out of Memory Killer (OOM Killer) — механизм ядра Linux, который освобождает оперативную память при её исчерпании за счёт принудительного завершения некоторых запущенных процессов. 

При исчерпании памяти в системе ядро Linux вызывает OOM killer, который по определённым правилам выбирает один процесс и убивает его. Освободившаяся память передаётся в распоряжение ядра, которое может предоставить её другим процессам. 

OOM Killer использует определённый набор правил для выбора процесса, который нужно «убить». В первую очередь будут завершены недавно запущенные пользовательские процессы, которые требуют большого объёма памяти и/или имеют множество дочерних процессов; в последнюю очередь будут завершаться системные процессы пользователя root, запущенные значительное время назад. 

Важно помнить, что OOM killer убивает процессы сигналом SIGKILL, не предоставляя им возможность корректно завершить своё выполнение (сохранить данные, вызвать другие процессы).  Поэтому частое срабатывание этого механизма может приводить к серьёзным последствиям в работе системы. 

---



## 40.  Почему в htop может быть не до конца корректная сводка по потребляемой памяти

Сводка по потребляемой памяти в htop может быть не до конца корректной из-за следующих факторов:

- VIRT — объём используемой виртуальной памяти. Здесь выводится тот объём памяти, который был запрошен процессом, даже если фактически используется меньше. Фактическое потребление памяти отображается в столбце RSS. 

- Возможность прямого отображения файлов в адресное пространство. Например, файл размером 10 ГБ будет отображаться как потребляющий 10 ГБ в столбце VIRT, хотя он использует мало физической памяти. 

- Некоторые веб-браузеры выделяют огромные области для изоляции JavaScript от остального кода. Большая часть этих областей остаётся пустой и поэтому не потребляет физическую память. 

---



## 41. Как процессы в системе взаимодействуют между собой?

**Трубы(пайпы '|')** — связь между двумя взаимосвязанными процессами. Механизм является полудуплексным, что означает, что первый процесс связан со вторым процессом. Для достижения полного дуплекса, т. Е. Для взаимодействия второго процесса с первым процессом требуется другой канал.

**FIFO** — Связь между двумя не связанными процессами. FIFO — это полный дуплекс, что означает, что первый процесс может взаимодействовать со вторым процессом и наоборот одновременно.

**Очереди сообщений** — связь между двумя или более процессами с полной дуплексной пропускной способностью. Процессы будут связываться друг с другом, отправляя сообщение и извлекая его из очереди. Полученное сообщение больше не доступно в очереди.

**Совместно используемая память.** Связь между двумя или более процессами достигается за счет совместного использования памяти всеми процессами. Совместно используемая память должна быть защищена друг от друга путем синхронизации доступа ко всем процессам.

**Семафоры** — семафоры предназначены для синхронизации доступа к нескольким процессам. Когда один процесс хочет получить доступ к памяти (для чтения или записи), он должен быть заблокирован (или защищен) и освобожден при удалении доступа. Это должно быть повторено всеми процессами для защиты данных.

**Сигналы** — Сигнал — это механизм связи между несколькими процессами посредством сигнализации. Это означает, что исходный процесс отправит сигнал (распознанный по номеру), а целевой процесс обработает его соответствующим образом.

---


## 42 Что такое QEMU.

QEMU — программа с открытым исходным кодом для эмуляции аппаратного обеспечения различных платформ. 

Содержит два режима эмуляции:

- Полный (System-mode). В этом случае программа создаёт автономную виртуальную машину с собственной основной и периферийной системами. 

- Пользовательский (User-mode). В этом режиме QEMU запускает на одном процессоре Linux процессы, скомпилированные для другого процессора. 
Может эмулировать следующие архитектуры: x86 (32 и 64 бит), ARM, SPARC, PowerPC (32 и 64 бит), MIPS, m68k (Coldfire), SH-4, CRISv2, Alpha, MicroBlaze. 

Работает на Syllable, FreeBSD, OpenBSD, FreeDOS, Linux, Windows 9x, Windows 2000, Mac OS X, Android и др.. 

---

## 43. Что такое KVM (гипервизор)


KVM (Kernel-based Virtual Machine) — технология аппаратной виртуализации на базе ядра Linux. 23 С помощью гипервизора KVM можно развернуть несколько виртуальных машин на реальном физическом сервере. 

Гипервизор KVM работает как один из процессов, которые выполняются основной ОС Linux. Такой гипервизор управляет всеми гостевыми операционными системами, а основная ОС выполняет эмуляцию (копирование функций основной ОС на гостевых ОС) и управляет ресурсами сервера. 

KVM позволяет виртуальным машинам использовать немодифицированные образы дисков, содержащие операционные системы. Каждая виртуальная машина имеет своё собственное виртуальное аппаратное обеспечение: сетевые карты, жёсткий диск, видеокарту и другие устройства. 

Изначально виртуализация KVM была разработана исключительно под Linux. В последующих вариантах была внедрена поддержка широкого ряда процессоров и ОС, среди которых, помимо Linux, наиболее известными являются Windows, CentOS, Solaris, BSD. 

---
## 44. Что такое qemu-kvm?


QEMU-KVM — это сочетание двух технологий виртуализации: QEMU и KVM. 

KVM (Kernel-based Virtual Machine) — гипервизор, работающий в виде модуля на ОС Linux. 3 Он обеспечивает доступ к аппаратной виртуализации на базе Intel VT (Virtualization Technology) либо AMD SVM (Secure Virtual Machine). 

QEMU (Quick Emulator) — эмулятор аппаратного обеспечения различных платформ, позволяющий запускать различные гостевые операционные системы. 23 Он может работать отдельно, но может использовать KVM для запуска виртуальных машин с более высокой скоростью. 

---




## 45. Что такое iowait и почему он может появляться?

I/O wait (iowait) — это процент времени, которое процессор тратит на ожидание завершения операций ввода-вывода. Он указывает на то, что система ожидает ресурсов диска или сети. 

Возможные причины высокого значения iowait:

- узкие места в слое хранения, из-за которых диску требуется больше времени для ответа на запросы ввода-вывода; 

- очередь запросов ввода-вывода в слое хранения, которая приводит к увеличению задержки;

- слишком медленные блочные устройства (например, физические диски); 

- процессы в состоянии непрерывного сна; 

- операции чтения и записи на диск в большом объёме; 

- подкачка раздела или файла из-за нехватки оперативной памяти в основной или гостевой операционной системе. 

High iowait может негативно влиять на производительность системы, замедляя её или вызывая такие проблемы, как низкая скорость транзакций в базе данных и ухудшение состояния приложений и баз данных. 

---


## 46. Что такое блочные устройства? Какие элементарные операции можно с ними производить?

Блочные устройства — это внешние устройства компьютера, обмен данными с которыми можно производить только блоками: целостной упорядоченной последовательностью байт. 

Примеры блочных устройств: жёсткие и floppy-диски, магнитные ленты, диски CDROM и другие. 

Для блочных устройств характерны следующие операции:

- Чтение и запись блока информации — read и write. 

- Поиск требуемого блока информации — seek (для устройств прямого доступа). 

Помимо общих операций, некоторые устройства могут выполнять операции специфические, свойственные только им. Например, звуковые карты умеют увеличивать или уменьшать среднюю громкость звучания, дисплеи умеют изменять свою разрешающую способность. 

---

## 47. Что такое символьные устройства? Какие элементарные операции с ними можно производить?


Символьные устройства — это устройства, к которым можно обращаться как к потоку байтов (так же как к файлу). 

Примеры символьных устройств: текстовый экран, последовательные порты. 

Для символьных устройств характерны следующие операции:

read() — возвращает один символ от начала до конечной позиции; 
write() — записывает новое содержимое в указанное место. 
Библиотеки верхнего уровня в операционной системе для символьных устройств допускают построчное редактирование посимвольно введённой информации. 


---


## 48. Что такое major and minor numbers блочных устройств, чему они соответствуют?

Major и minor numbers — это номера устройств в UNIX/Linux-системах. 

Major number — более общая категория устройства (например, жёсткие диски, устройства ввода-вывода и т. д.). 

Minor number — более конкретный номер устройства (например, указывает, к какой шине подключено устройство). 

Эти номера используются операционной системой, чтобы определить фактический драйвер и устройство, к которому обращается запрос пользователя. 

---



## 49. Что такое файловая система? Для чего она нужна?


Файловая система — это способ хранить и организовывать информацию на каком-нибудь носителе. От файловой системы зависит, как файлы будут кодироваться, храниться на диске и читаться компьютером. У каждой операционной системы свой тип организации файлов, то есть своя файловая система. 3

Основные функции файловой системы:

- размещение и упорядочивание на носителе данных в виде файлов; 

- определение максимально поддерживаемого объёма данных на носителе информации; 

- создание, чтение и удаление файлов; 

- назначение и изменение атрибутов файлов; 

- определение структуры файла; 

- поиск файлов; 

- организация каталогов для логической организации файлов; 

- защита файлов при системном сбое; 

- защита файлов от несанкционированного доступа и изменения их содержимого. 

Без файловой системы не получится работать с файлами. Она управляет хранилищем и делает разрозненную информацию в нём понятной для операционной системы и прикладного ПО. 

---



## 50. Как создать файловую систему на блочном устройстве? Какие параметры можно задать при создании?


Чтобы создать файловую систему на блочном устройстве в Linux, используется команда mkfs. Её синтаксис выглядит следующим образом: sudo mkfs -t тип устройство. 

Дополнительные параметры:

-с — проверить устройство на наличие битых секторов; 
-b — размер блока файловой системы; 
-j — использовать журналирование для ext3; 
-L — задать метку раздела; 
-v — показать подробную информацию о процессе работы; 
-V — версия программы. 

Примеры команд:

sudo mkfs -t ext4 -L root /dev/sda6 — создание файловой системы ext4 на устройстве /dev/sda6. 2

---
## 51. Что такое **inodes айноды**


Inode (произносится как а́йнод или инод) — это структура данных в традиционных для ОС UNIX файловых системах, таких как UFS, ext4. В этой структуре хранится метаинформация о стандартных файлах, каталогах или других объектах файловой системы, кроме непосредственно данных и имени. 

Каждый файл или каталог в системе имеет свой уникальный номер inode, который используется для идентификации файла или каталога на уровне ядра операционной системы. 

Inode имеют ограниченный размер, поэтому количество файлов или каталогов, которые могут быть созданы в файловой системе, ограничено. Однако файловые системы в Linux могут использовать различные стратегии для увеличения количества доступных inode. 

---

## 52. Где физически находятся inodes айноды

Inode (индексный дескриптор) физически находятся в начале раздела диска. 

В начале раздела расположен суперблок, в котором находятся метаданные всей файловой системы. За ним идут несколько зарезервированных блоков, а затем размещена таблица Inode и только после неё блоки с данными. 


---


## 53. По какой причине и на какого типа системах айноды могут закончиться? И к чему это может привести?

Inodes (индексные дескрипторы) могут закончиться по следующим причинам:

- Создание большого количества файлов. Например, если в какой-то директории накапливается множество временных файлов кэша или сессий. 

- Неправильная настройка PHP-скриптов. Некоторые PHP-скрипты или веб-приложения могут создавать временные файлы или кэшировать данные, которые не удаляются автоматически. 

Если inodes исчерпываются, это может привести к следующим проблемам:

- Ошибки с функционированием файловой системы. Возможны задержки при чтении, записи или доступе к файлам. 

- Ошибки и сбои в работе различных компонентов системы. Особенно если файловая система используется множеством приложений или пользователей. 

Inodes используются в файловых системах Linux, таких как ext2, ext3, ext4, XFS, JFS и других. Каждая файловая система имеет свои собственные способы управления inode и максимальное количество inode, которое может быть создано в этой файловой системе. 

---


## 54. Какая файловая система бывает динамическими айнодами и что это такое, зачем нужно?


XFS — файловая система, которая использует механизм динамического выделения inodes по запросу. Это освобождает пользователя от необходимости предсказывать количество необходимых файлов и пересоздавать файловую систему, если это количество было угадано неверно. 

Inodes — это структура данных, которая содержит метаинформацию о файлах и каталогах в Linux. Изменение inodes может повлиять на работу файловой системы и привести к потере данных, поэтому при работе с ними необходимо соблюдать осторожность. 

---


## 55.Где хранится информация об именах файлов, директорий?


- Inodes не содержат имён файлов, только другие метаданные файла.
- Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса.
- Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса.

Таким образом имя файла/директории хранится в информационной структуре каталогов.

---


## 56. Каким образом осуществляется монтирование ФС? Как можно посмотреть список примонтированных ФС?


Для монтирования файловых систем в Linux используется команда mount. 23 Чтобы узнать, какие файловые системы смонтированы, нужно дать команду mount без параметров. 

По умолчанию вывод будет включать все файловые системы, включая виртуальные, такие как cgroup, sysfs и другие. Каждая строка содержит информацию об имени устройства, каталоге, в который оно смонтировано, типе файловой системы и параметрах монтирования. 

Чтобы отобразить только определённые файловые системы, используйте параметр -t. Например, чтобы распечатать только разделы ext4, нужно использовать: mount -t ext4. 

Чтобы отсоединить (размонтировать) смонтированную файловую систему, используется команда umount, после которой укажите либо каталог, в котором она была смонтирована (точка монтирования), либо имя устройства. 


---


## 57. Что такое псевдофайловая система?

Псевдофайловая система — это файловая система, в которой нет реальных файлов, а есть виртуальные записи, которые файловая система сама создаёт на месте. 

Примеры псевдофайловых систем в Linux:

- proc — хранит информацию о текущем наборе элементов управления.  Большинство файлов доступны только для чтения, но есть и доступные на запись, через которые можно изменять переменные ядра. 

- sysfs — предоставляет интерфейс к структурам данных ядра. Файлы в sysfs показывают информацию об устройствах, модулях ядра, файловых системах и других компонентах ядра. 

---

## 58.Какие проблемы могут возникать с файловой системой и жёстким диском? Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?


Возможные проблемы с файловой системой и жёстким диском:

- неожиданное отключение питания; 
- системные сбои; 
- небезопасное извлечение диска. 

При незначительном повреждении файловой системы её можно восстановить.  Для этого используются специальные утилиты, такие как TestDisk, Mondo Rescue, ddrescue, Redo Backup and Recovery и другие. 

Если файловая система не может быть восстановлена, рекомендуется создать её резервную копию. Для этого можно использовать инструменты исследовательского анализа, например, sleuthkit. 

Чтобы снова использовать том, его необходимо отформатировать с созданием новой файловой системы. Все данные при этом будут удалены. 

---





## 59.Какую файловую систему выбрать ext4 или xfs?

XFS — оптимизирована для передачи больших файлов и параллельных операций ввода-вывода. Подходит для высокопроизводительных вычислений и хранения данных. Имеет встроенные инструменты резервного копирования и восстановления. Однако не поддерживается так широко, как Ext4, и может быть несовместима со всеми операционными системами. 

Ext4 — оптимизирована для общего использования с акцентом на безопасность. Поддерживает расширенные разрешения на уровне файлов и каталогов. 2 Однако не имеет параллельного ввода-вывода, поэтому её производительность может быть ниже при работе с большими файлами. 

Таким образом, Ext4 — хороший выбор для рабочих станций и настольных компьютеров, когда ресурсы и пропускная способность ограничены. ** 3XFS** — для больших серверов с большим количеством ресурсов, которые будут работать с большими файлами и несколькими потоками. 

---



## 60. Как определить, на каком физическом жёстком диске находится раздел с файловой системой? Как можно идентифицировать этот носитель без выключения сервера?


В Linux. Используйте команду lsblk -f. Она выведет список физических дисков и их файловые системы. 

---

## 61. Какую файловую систему Вы бы выбрали для работы с большим количеством файлов?


Для работы с большим количеством файлов в Linux можно выбрать ReiserFS. Она специально создана для этой задачи и обладает множеством функций, направленных на повышение производительности файлов небольшого размера. 

Также стоит учитывать технические аспекты и особенности предполагаемого применения. Например, для серверов с высокими требованиями к производительности могут лучше подойти XFS или Btrfs. В то же время для портативных устройств или систем с ограниченными возможностями может быть предпочтительнее применение более простых файловых систем, вроде Ext2 или FAT32. 

---

## 62. Как узнать, какими процессами используется раздел?

В Linux:

Используйте утилиту ps. Для просмотра всех процессов добавьте опцию -e, а для максимально подробной информации — опцию -F. 
Также можно воспользоваться утилитами top, htop, atop и другими. 

---


## 63. Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?


Файл /etc/fstab содержит статичную информацию о файловой системе. В нём указана информация для автоматического монтирования дисков при загрузке компьютера. 

Файл /etc/mtab содержит динамическую информацию о файловых системах. 

Файл /etc/mdadm/mdadm.conf содержит информацию о RAID-массивах и компонентах, которые в них входят. 


---

## 64.Отличие хардлинков от симлинков hardlinks symlinks

Жёсткие ссылки (hardlink) — это копия того файла, на который они ссылаются. 2 Работают только в пределах одной файловой системы и не могут ссылаться на каталоги. 

Символические ссылки (symlink) — это файлы особого типа, которые ссылаются на другие файлы по имени, а не прямо по номеру инода. Могут ссылаться на объекты другой файловой системы. Если файл, на который указывает ссылка, исчезает, то она перестаёт работать. 

---

## 65.Что такое RAID? Какие основные типы RAID существуют, чем они отличаются?


RAID (англ. Redundant Array of Independent Disks — избыточный массив независимых дисков) — технология виртуализации данных для объединения нескольких физических дисковых устройств в логический модуль для повышения отказоустойчивости и (или) производительности. 

Основные типы RAID-массивов:

- RAID 0 (чередование — Striping).  Уровень основан на разделении информации по блокам с одновременной записью разных блоков по разным дискам. 

- RAID 1 (зеркалирование — Mirror).  Подразумевает использование от 2 до 4 накопителей. Однако при этом теряется половина объёма дисков, поскольку это пространство используется резервированием данных. 

- RAID 5 (чередование с чётностью).  Для подобной конфигурации необходимо минимум 3 диска, а максимальное допустимое количество — 16. 

- RAID 6 (чередование с двойной чётностью).  Отличие состоит в записи информации для восстановления на два диска. 

- RAID 10 — микс RAID массивов 1 и 0. Объединяет в себе плюсы от каждого: высокая производительность и высокая отказоустойчивость. 


Условно массивы можно разделить на 3 основных вида:

- Программные (Software). Массив создается средствами встроенных возможностей операционной системы, а за обработку данных отвечает ЦП. 

- Аппаратные (Hardware). Создаются на основе отдельного контроллера. 

- Интегрированный (RAID-on-chip, fake-RAID). Комбинация программных и аппаратных методов зеркалирования. 


---

## 66. Какие средства для работы с программными RAID массивами существуют в linux?

Для работы с программными RAID-массивами в Linux используется утилита mdadm (Multiple Device Administration). 

Возможности mdadm:

- создание, изменение, мониторинг и управление RAID-массивами из командной строки; 
- сборка массивов из существующих компонентов; 
- получение информации о состоянии и конфигурации RAID-массива. 

---
## 67. Что такое LVM? Для решения каких задач он предназначен?


LVM (Logical Volume Manager) — это технология управления устройствами хранения, позволяющая объединять области различных физических устройств в один логический том. 

Задачи LVM:

- создание отдельных логических томов из нескольких физических томов или целых жёстких дисков, позволяющее динамически изменять размер тома; 

- управление большими фермами жёстких дисков за счёт возможности добавления и замены дисков без простоев или сбоев в обслуживании в сочетании с горячей заменой; 

- в небольших системах (например, настольных) вместо необходимости оценивать во время установки, насколько большим может быть раздел, LVM позволяет легко изменять размер файловых систем по мере необходимости; 

- выполнение согласованного резервного копирования путём создания моментальных снимков логических томов; 

- шифрование нескольких физических разделов одним паролем. 

LVM можно рассматривать как тонкий программный слой поверх жёстких дисков и разделов, который создаёт абстракцию непрерывности и простоты использования для управления заменой жёсткого диска, перераспределением разделов и резервным копированием. 

---


## 68. Что такое loop devices? Как их можно использовать?


Loop device — это виртуальное или псевдоустройство в Linux, которое позволяет использовать обычный файл как блочное устройство. 

Примеры использования loop devices:

- Создание файловой системы с обычным файлом, когда нет свободного раздела диска. 

- Доступ к содержимому ISO-образов устанавливаемых операционных систем. 

Для управления loop devices в Linux используется команда losetup. Она позволяет создавать новые loop devices, отсоединять их и получать информацию о существующих. 

---

## 69.При создании нового файла система возвращает ошибку no space left device

Ошибка «No space left on device» в Linux означает, что на разделе диска, куда программа собирается писать свои данные, закончилось свободное место. 

Чтобы исправить ошибку, можно:

- Удалить ненужные файлы. Например, очистить корзину или удалить временные файлы из каталогов /tmp и /var/tmp. 

- Увеличить размер раздела. Для этого можно использовать утилиты fdisk, lsblk или gdisk. 

- Очистить кэш пакетного менеджера. Для этого можно использовать команды sudo apt clean или yum clean all. 

- Найти дубликаты файлов. Для этого можно использовать утилиту BleachBit. 

- Удалить старые ядра. Ядро Linux довольно часто обновляется, и старые ядра остаются в каталоге /boot. 

---

## 70. df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)

Разница в показаниях команд df и du может возникать из-за удалённых файлов, которые всё ещё используются каким-либо процессом. 

В этом случае остаётся открытым файловый дескриптор в псевдо-файловой системе proc (в /proc/номер-процесса/fd/). Пространство, занимаемое таким файлом, программа df считает используемым, а программа du не просуммирует его, так как уже нет файлов, с ним ассоциированных. 

Чтобы просмотреть информацию о таких удалённых, но всё ещё открытых файлах, можно воспользоваться командой: sudo lsof | grep '(deleted)'. После этого нужно перезапустить те процессы, которые всё ещё используют удалённые файлы. 

---

## 71.Сервер не отвечает, как можно получить доступ к серверу, не находясь непосредственно в ЦОДе

KVM (keyboard video mouse) — это модуль, позволяющий с использованием выделенного адреса подключаться к серверу удалённо и управлять его консолью. 1

IPMI (Intelligent Platform Management Interface) — интерфейс для удалённого управления сервером. Он предназначен для автономного мониторинга и управления функциями, встроенными в аппаратное оснащение сервера. IPMI работает независимо от операционной системы на сервере.

---
## 72. Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?

Чтобы найти причину ошибки 502 на веб-сервере в Linux, можно выполнить следующие шаги:

- Проверить подключение к серверу. Для этого можно использовать команду ping. Если сервер недоступен, то возможны проблемы с сетью или брандмауэром. 

- Проверить настройки DNS. Убедитесь, что доменное имя указывает на правильный IP-адрес сервера. 

- Просмотреть логи доступа. В них можно найти информацию о посетителях, путях запросов, деталях сервера и временных метках. 

- Проверить конфигурацию брандмауэра. Для этого можно использовать команду iptables. 

- Отладить код сервера. Это может помочь выявить ошибки в логике обработки запросов. 

- Обратиться к хостинг-провайдеру. Если вы используете управляемый хостинг, то проблемы на их инфраструктуре могут приводить к ошибкам на вашем сайте. 


---

## 73. В директории находится файл с нечитаемым содержимым. Каким образом можно узнать формат хранения данных и предназначение файла?


Чтобы узнать формат хранения данных и предназначение файла в Linux, можно воспользоваться командой file. 

Синтаксис: file [option] filename. 

---


## 74. Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?

Ошибка «No such file or directory» в Linux возникает, когда программа пытается получить доступ к файлу или каталогу, который не существует.  Это может происходить по разным причинам, например:

- файл или каталог был удалён; 
- файл или каталог находится в другом месте, чем ожидает программа; 
- файл или каталог защищён от доступа; 
- файл или каталог повреждён. 

Чтобы исправить ошибку, можно попробовать следующие решения:

- Проверить, существует ли файл или каталог. Если он не существует, нужно создать его. 
- Проверить правильность написания имени файла или каталога. 
- Убедиться, что вы находитесь в правильном каталоге. 
- Проверить разрешения файла или каталога. Если файл или каталог недоступен, нужно изменить разрешения, чтобы он стал доступным. 
- Попробовать восстановить файл или каталог с помощью утилиты для восстановления файлов. 

---

## 75. Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?


Strace — это утилита, которая отслеживает системные вызовы. Она обеспечивает интерфейс между процессом и операционной системой (ядром). 

Line-buffered — это режим буферизации, при котором буфер сбрасывается при встрече с символом новой строки. 


Вот пример использования strace с режимом line-buffered:

Чтобы отследить системные вызовы программы ls в режиме буферизации, выполните команду:

strace -e trace=open,read -o output.txt ls /home.


В результате в файл output.txt будет записана последовательность выполнения команды ls от начала до конца.

---

## 76. Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)


Если у команды chmod убрали права на исполнение, можно восстановить их следующим образом:

- Скопировать содержимое команды chmod в другую исполняемую команду. Например, в mkdir. 

- Восстановить права на исполнение команды chmod. Для этого можно использовать команду: mkdir +x /usr/bin/chmod. 

- Восстановить оригинальную команду chmod из резервной копии. 


Setfacl (Set File Access Control List) — это командная утилита в Linux, которая позволяет пользователям устанавливать списки контроля доступа (ACL) для файлов и каталогов. 

ACL дают большую гибкость, чем стандартный набор полномочий «пользователь/группа/остальные». 4 Они позволяют указывать разрешения для пользователей и групп. 

---



## 77. База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?

ОПАСНО!!!: нужно выключить fsync, чтобы база не дожидалась записи с данных на диск, а как бы сохраняла.

Linux может отдавать успешную запись, когда он к себе положил в буфер, а не когда на диск засинкал. Это немного костыльный режим работы, даже скорее опасный, рискованный. Питание вырубят в этот момент, и все навернется. Но зато этот метод ускоряет запись на порядок.


Fsync — это системный вызов для POSIX-систем, который синхронизирует состояние файла в памяти с состоянием на диске. 

Fsync даёт инструкцию операционной системе, чтобы любые изменения или записи, сделанные в файле, который находится в буфере, немедленно сохранялись на диске и были успешно сохранены на диске к моменту возврата вызова. Это позволяет восстановить данные даже в случае сбоя системы или потери питания. 

---


## 78. Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?

В операционных системах Linux память делится на основные категории: использованную и не использованную. Но эта неиспользованная память еще разделена на "свободную" и "доступную".

Свободная память - это память, которая сейчас не используется ни для чего. Она полностью пуста.

Доступная память - это свободная память + память, используемая буферами и кэшами. Важно понимать, что буферы и кэши - это "мягкая" использованная память. Операционная система использует эту память для ускорения операций, но она может быть освобождена и использована приложениями, если потребуется больше памяти.

Поэтому, когда вы видите, что доступной памяти больше, чем свободной, это значит, что часть вашей памяти в настоящее время используется оптимизациями системы, но может быть освобождена и предоставлена приложению при необходимости.

---
## 79. Что такое разделяемая память?

Разделяемая память - это механизм, позволяющий нескольким процессам общаться и обмениваться данными, используя общую область памяти. Это один из самых быстрых способов взаимодействия между процессами, поскольку данные не отправляются через ядро операционной системы.

---

## 80. Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.

Возможно, причина замедления в перегрузке оборудования или в неэффективности запросов. Возможные шаги для оптимизации могут включать:

- Оптимизация запросов: Проверьте, нет ли избыточных или неэффективных запросов к базам данных. Некоторые запросы могут быть оптимизированы и выполнены быстрее.

- Индексирование: Убедитесь, что ваши данные правильно проиндексированы. Неиндексированный поиск может быть очень медленным.

- Балансировка нагрузки: Если у вас есть несколько серверов, убедитесь, что нагрузка равномерно распределена между ними.

- Скалирование: Возможно, ваша текущая конфигурация сервера просто не может справиться с текущим объемом данных/запросов. В этом случае увеличение мощности оборудования или добавление дополнительных серверов может быть решением.

- Мониторинг: Используйте инструменты мониторинга ресурсов (например, top, htop, iostat, vmstat итд.) для определения, где происходит узкое место.

Мониторинг и оптимизация производительности - это непрерывный процесс. Регулярная проверка и оптимизация могут помочь отслеживать и решать проблемы производительности, прежде чем они станут серьезной проблемой.

---


